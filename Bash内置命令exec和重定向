shell的内建命令exec将并不启动新的shell，而是用要被执行命令替换当前的shell进程，并且将老进程的环境清理掉，而且exec命令后的其它命令将不再执行。 
因此，如果你在一个shell里面，执行exec ls那么，当列出了当前目录后，这个shell就自己退出了，因为这个shell进程已被替换为仅仅执行ls命令的一个进程，执行结束自然也就退出了。为了避免这个影响我们的使用，一般将exec命令放到一个shell脚本里面，用主脚本调用这个脚本，调用点处可以用bash a.sh，（a.sh就是存放该命令的脚本），这样会为a.sh建立一个sub shell去执行，当执行到exec后，该子脚本进程就被替换成了相应的exec的命令。 
source命令或者"."，不会为脚本新建shell，而只是将脚本包含的命令在当前shell执行。 
不过，要注意一个例外，当exec命令来对文件描述符操作的时候，就不会替换shell，而且操作完成后，还会继续执行接下来的命令。 

Bash内置命令exec可以替换当前程序而不需要启动一个新的进程，可以改变标准输入和输出而不需要启动一个新的子进程。
如果文件用exec打开，read命令就会把文件指针每次指向下一行直到文件的末尾，如果要重新从文件开始读取，则必须把文件关闭再重新打开。

1、替换当前shell，执行某个命令，命令终止，shell也就终止了
$exec ls

2、打开文件作为当前shell的标准输入
$exec <file_name

3、打开文件作为当前shell的标准输出
$exec >file_name

4、打开文件作为输入，并分配文件描述符
$exec 3<datafile

5、打开文件作为输出，并分配文件描述符
$exec 4>datafile

6、创建文件描述符fd4的拷贝fd5
$exec 5<&4

7、关闭文件描述符
$exec 3<&- //关闭输入文件描述符
$exec 4>&- //关闭输出文件描述符

注意: <&和重定向操作符>&、&>的区别

例子：

$exec 3>filex //打开文件filex并分配文件描述符3，作为输出
$who >& 3 //who命令的输出输出到filex
$date >& 3 //date命令的输出输出到filex
$exec 3>&- //关闭filex
$exec 3<filex //重新打开文件filex并分配文件描述符3，作为输入
$cat <& 3 //重定向cat命令的输入到文件描述符3，即文件filex
$exec 3<&- //关闭filex

下面描述如何准确控制并发的进程数目。

 #!/bin/bash
# 2006-7-12, by wwy
#-----------------------------------------------------------------------------------
# 此例子说明了一种用wait、read命令模拟多线程的一种技巧
# 此技巧往往用于多主机检查，比如ssh登录、ping等等这种单进程比较慢而不耗费cpu的情况
# 还说明了多线程的控制
#-----------------------------------------------------------------------------------

function a_sub { # 此处定义一个函数，作为一个线程(子进程)
sleep 3 # 线程的作用是sleep 3s
}


tmp_fifofile="/tmp/$$.fifo"
mkfifo $tmp_fifofile      # 新建一个fifo类型的文件
exec 6<>$tmp_fifofile      # 将fd6指向fifo类型
rm $tmp_fifofile


thread=15 # 此处定义线程数
for ((i=0;i<$thread;i++));do 
echo
done >&6 # 事实上就是在fd6中放置了$thread个回车符


for ((i=0;i<50;i++));do # 50次循环，可以理解为50个主机，或其他

read -u6 
# 一个read -u6命令执行一次，就从fd6中减去一个回车符，然后向下执行，
# fd6中没有回车符的时候，就停在这了，从而实现了线程数量控制

{ # 此处子进程开始执行，被放到后台
      a_sub && { # 此处可以用来判断子进程的逻辑
       echo "a_sub is finished"
      } || {
       echo "sub error"
      }
      echo >&6 # 当进程结束以后，再向fd6中加上一个回车符，即补上了read -u6减去的那个
} &

done

wait # 等待所有的后台子进程结束
exec 6>&- # 关闭df6
exit 0


sleep 3s，线程数为15，一共循环50次，所以，此脚本一共的执行时间大约为12秒
即：
15x3=45, 所以 3 x 3s = 9s
(50-45=5)<15, 所以 1 x 3s = 3s 
所以 9s + 3s = 12s

$ time ./multithread.sh >/dev/null
real        0m12.025s
user        0m0.020s
sys         0m0.064s


而当不使用多线程技巧的时候，执行时间为：50 x 3s = 150s。

此程序中的命令mkfifo tmpfile和linux中的命令mknod tmpfile p
效果相同。区别是mkfifo为POSIX标准，因此推荐使用它。该命令创建了一个先入先出的管道文件，并为其分配文件标志符6。管道文件是进程之间通信的一种方式，注意这一句很重要
exec 6<>$tmp_fifofile      # 将fd6指向fifo类型
如果没有这句，在向文件$tmp_fifofile或者&6写入数据时，程序会被阻塞，直到有read读出了管道文件中的数据为止。而执行了上面这一句后就可以在程序运行期间不断向fifo类型的文件写入数据而不会阻塞，并且数据会被保存下来以供read程序读出。

